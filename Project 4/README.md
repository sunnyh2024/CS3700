<p>Our high level approach was to use some very basic features of TCP, namely the sliding window feature. Our implementation mainly uses a dictionary to keep track of the packets that are 'in transit', that is, packets that we have sent but that have not yet been ACKed. Our window was mainly used to make sure that this dictionary did not grow too large as we kept sending packets. Once a packet in the dictionary was ACKed, we would remove it. We also had a feature that would retransmit the packets in this dictionary if too much time had passed since its last transmission. After we retransmit, we slightly increment the time that we wait before we retransmit this packet again, so as to avoid transmitting too much on a network with high latency. </p>

<p>The biggest challenge that we faced was trying to handle cases where packets were dropped. The hardest cases for our implementation were the cases where the ACKs from the receiver were dropped on their way to the sender. This was especially a problem when the receiver already had the entire reconstructed file, and thus the sender would keep sending unACKed packets when the receiver had already shut down. We also had trouble deciding which features to implement, and how similar to TCP we wanted our protocol to be. </p>

<p>In terms of testing, most of our testing was done with the resources given to us. At first, we mainly tested our code with the basic 'nettest' and 'testall' functions. Once we had a basic idea of the tests that were failing, we moved more towards the nettests with custom 'netsim' settings. We replicated the settings on the 'testall' tests we were failing to try and pass particular cases until all the tests were passing. </p>